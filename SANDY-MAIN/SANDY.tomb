struct body_ram{ 
    name : string; //users could name their Sandy to whatever they want,
}

struct body_rom{
    created: timestamp;
    dna : bytes; //could do some cool math with bytes that lead to a bigger picture
    name: string;
    descritpion: string;
    infoURL: string;
    imageURL: string;
}
token SANDY {

    import NFT;
    import Runtime;
    import UID;

    global _owner: address;
    global owns_sandy: storage_map<address,number>:
    global _timeGate: bool; //will be used to limit address buying Sandys.
    global _infusionAmt: number;
    gloabl _infusionTkn: string;


	const SANDY_SUPPLY: number = 500;
    property name: string = "Test";//Will change to SANDY once thoroughly tested
    property symbol: string = "TST";// Will change once properly tested
    property isBurnable: bool = true;
	property maxSupply: number = 0;
    property owner:address = _owner




    nft character< body_rom, body_ram>{

        property name: string{
            return _ROM.name;
        }

        property description: string{
            return _ROM.description;

        }
        property infoURL: string{
            return _ROM.infoURL;

        }
        property imageURL: string{
           return  _ROM.imageURL;

        }

        property create: timestamp{
            return _ROM.create;

        }

        property dna: bytes{
            return _ROM.dna;

        }


    }
      constructor(owner:address)
    {
        _owner = owner;
        _timeGate = true;
        _infusionAmt = 25;
        _infusionTkn = 'SOUL';
        //params: _owner,$THIS_SYMBOL,1?,SANDY_SUPPLY,TOKENSERIES.DUPLICATE,character
        NFT.createSeries(from:Address, symbol:String, seriesID:Number, maxSupply:Number, mode:Enum, nft:Module)
    }
    //logic to ensure mint stays withing specified bounds
   
   //a little something special Do LATER!!
	private configureDNA(){
        //encode bytes for an image.
	}
	//Mint nft from contract address and transfer to 
    private mint(creator:address,to:address,created:timestamp,dna: bytes,name: string,descritpion: string,infoURL: string,imageURL: string,id:number) 
    {
         /*
        Possible Issue: What if transaction fails and buyer address is still added to storage_map?
        Answer?: only add user to storage_map once mint is confirmed.
        what does 
        */
		local rom:body_rom = Struct.body_rom(Time.now(),this.configureDNA(),name,description,infoURL,imageURL);
        local ram:body_ram = Struct.body_ram("SANDY");//template name for now
        if(this.checkTimeGate()){
            //Runtime.expect(this.hasSANDY(creator) == false,'Cannot purchase due to you already owning a SANDY');
            Runtime.expect(owns_sandy.has(to) == false,'Cannot purchase due to you already owning a SANDY');
            //add logic to mint sandy and add creator to list of sandy owners
           
            //params:creator,to,$THIS_SYMBOL,body_rom,body_ram,id
            NFT.mint(from:Address, to:Address, symbol:String, rom:Any, ram:Any, seriesID:Number)
            //params: creator,$THIS_SYMBOL,id,_infusionTkn,_infuseAmt
            NFT.infuse(from:Address, symbol:String, id:Number, infuseSymbol:String, infuseValue:Number);
            //assuming the minter is the to
            owns_sandy.set(to,true);
        }
        else{
            //will still need to add creator to list of sandy owners

             //params:creator,to,$THIS_SYMBOL,body_rom,body_ram,id
            NFT.mint(from:Address, to:Address, symbol:String, rom:Any, ram:Any, seriesID:Number)
            //params: creator,$THIS_SYMBOL,id,_infusionTkn,_infuseAmt
            NFT.infuse(from:Address, symbol:String, id:Number, infuseSymbol:String, infuseValue:Number);
        }
    } 
    private checkTimeGate():bool
    {
        // check if valie to limit 1 mint per address is valid
        if (_timeGate)
        {
            return true;
        }
        return false;
    }
    
    public timeGate_switch(){
        Runtime.expect(Runtime.isWitness(_owner),'witness failed');
        _timeGate = !_timeGate; //assuming negation works in phantasma. This should just negate the value.
    }

    //IF NFT.mint keeps track of MAX mint then there is no need for this function
	 private validateMint(creator:address)
    {
        //Runtime.expect(Runtime.isWitness(creator),'witness failed');
		Runtime.expect(mintNum > 0,'Mint must be greater than 0');
		Runtime.expect(mintNum <= SANDY_SUPPLY,'Maximum number of SANDY has been minted');

    }



	//@Param MintNum - keeps track of how many current mints there are. May need to find a correct way to implement this
    public mintToken(creator:address,to:address,created:timestamp,dna: bytes,name: string,descritpion: string,infoURL: string,imageURL: string){
        Runtime.expect(Runtime.isWitness(creator));
        this.mint(creator:address,to:address,created:timestamp,dna: bytes,name: string,descritpion: string,infoURL: string,imageURL: string);
    
    }
    public transerNFT(from:address,to:address){

        NFT.tranfer();
        
    }

	//will have to make sure that the owner is the only one who can edit the sandy name
    public editSANDY(nftOwner:address,tokenID:number,name:string ){
        Runtime.expect(Runtime.isWitness(nftOwner),'Must be owner of NFT');//have to find a way to get current nft owner
		local ram:editRam = Struct.body_ram(name);
		//my assumption that write must follow the order of the struct 
        NFT.write(nftowner,$THIS_SYMBOL,tokenID,editRam);//changeable data


    }
    //need to get readable rom 
    public getRom(tokenID){
        NFT.readROM(symbol:string, id:Number)

    }
    public getRam(tokenID){

        NFT.readRAM(symbol:string, id:Number)
    }
    //Mint function
    trigger onMint(from: address, to: address, symbol: string, tokenID: number) {
		Runtime.expect(Runtime.isWitness(_owner), "witness failed"); 
		Runtime.expect(symbol == $THIS_SYMBOL, "symbol mismatch"); 
    }
    trigger onInfuse(from: address, to: address, symbol: string, tokenID: number){
        Runtime.expect(Runtime.isWitness(from), "witness failed");
    }

    trigger onSeries(from: address, to: address, symbol: string, tokenID: number){
        Runtime.expect(Runtime.isWitness(from), "witness failed");
    }
    trigger onWrite(from: address, to: address, symbol: string, tokenID: number){
        Runtime.expect(Runtime.isWitness(from), "witness failed");
    }
    trigger onSend(from: address, to: address, symbol: string, tokenID: number){
        Runtime.expect(Runtime.isWitness(from), "witness failed");
    }
    trigger onBurn(from: address, to: address, symbol: string, tokenID: number) {
		Runtime.expect(Runtime.isWitness(from), "witness failed");
		
    }


}