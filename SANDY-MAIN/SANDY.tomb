struct body_ram{ 
    name : string; //users could name their Sandy to whatever they want,
}

struct body_rom{
    created: timestamp;
    dna : bytes; //could do some cool math with bytes that lead to a bigger picture
    name: string;
    description: string;
    infoURL: string;
    imageURL: string;
}
token SANDY {

    import NFT;
    import Runtime;
    import UID; 
    import Time;
    import Map;

    global _owner: address;
    global owns_sandy: storage_map<address,bool>; 
    global _timeGate: bool; //will be used to limit address buying Sandys.
    global _infusionAmt: number;
    global _infusionTkn: string;


	const SANDY_SUPPLY: number = 500;
    property name: string = "Test";//Will change to SANDY once thoroughly tested
    property symbol: string = "TST";// Will change once properly tested
    property isBurnable: bool = true;
	property maxSupply: number = 0;
    property owner:address = _owner;


    nft character<body_rom, body_ram> {

        property name: string{
            return _ROM.name;
        }

        property description: string{
            return _ROM.description;

        }
        property infoURL: string{
            return _ROM.infoURL;

        }
        property imageURL: string{
           return  _ROM.imageURL;

        }

        property created: timestamp{
            return _ROM.created;

        }

        property dna: bytes{
            return _ROM.dna;

        }

    }
      constructor(owner:address)
    {
        _owner = owner;
        _timeGate = true;
        _infusionAmt = 25;
        _infusionTkn = "SOUL";
        //params: _owner,$THIS_SYMBOL,1?,SANDY_SUPPLY,TOKENSERIES.DUPLICATE,character
        //NFT.createSeries(from:, symbol:String, seriesID:Number, maxSupply:Number, mode:Enum, nft:Module);
    }
    //logic to ensure mint stays withing specified bounds
   
   //a little something special Do LATER!!
	private insertDNA(dna:bytes):bytes {
        //encode bytes for an image.
        //manipulate some dna
        return 0x04;
	}

    private checkTimeGate():bool
    {
        // check if valie to limit 1 mint per address is valid
        if (_timeGate)
        {
            return true;
        }
        return false;
    }
	//Mint nft from contract address and transfer to 
    private mint(creator:address,to:address,created:timestamp,dna: bytes,name: string,description: string,infoURL: string,imageURL: string,id:number) 
    {
         /*
        Possible Issue: What if transaction fails and buyer address is still added to storage_map?
        Answer?: only add user to storage_map once mint is confirmed.
        what does 
        */
        // so we're going to mint 500 nfts off rip
        // If they are clainming a SANDY then this will work differently 
        

		local rom:body_rom = Struct.body_rom(Time.now(),this.insertDNA(dna),name,description,infoURL,imageURL);
        local ram:body_ram = Struct.body_ram("SANDY");//template name for now
        if(this.checkTimeGate()){
            //Runtime.expect(this.hasSANDY(creator) == false,'Cannot purchase due to you already owning a SANDY');
            Runtime.expect(owns_sandy.has(to) == false,"Cannot purchase due to you already owning a SANDY");
            //add logic to mint sandy and add creator to list of sandy owners
           
            //params:creator,to,$THIS_SYMBOL,body_rom,body_ram,id
            NFT.mint(creator, to, $THIS_SYMBOL, rom, ram, 1);//might change the series ID later
            //params: creator,$THIS_SYMBOL,id,_infusionTkn,_infuseAmt
            NFT.infuse(creator, $THIS_SYMBOL, id, _infusionTkn, _infusionAmt);
            //assuming the minter is the to
            owns_sandy.set(to,true);
        }
        else{
            //will still need to add creator to list of sandy owners

             //params:creator,to,$THIS_SYMBOL,body_rom,body_ram,id
            NFT.mint(creator, to, $THIS_SYMBOL, rom, ram, 1);
            //params: creator,$THIS_SYMBOL,id,_infusionTkn,_infuseAmt
            NFT.infuse(creator, $THIS_SYMBOL, id, _infusionTkn, _infusionAmt);
        }
    } 
    
    
    public timeGate_switch(){
        Runtime.expect(Runtime.isWitness(_owner),"witness failed");
        _timeGate = !_timeGate; //assuming negation works in phantasma. This should just negate the value.
    }

    //IF NFT.mint keeps track of MAX mint then there is no need for this function
	 private validateMint(creator:address)
    {
        //not sure how to get a mint Number --> find out
        //Runtime.expect(Runtime.isWitness(creator),'witness failed');
		//Runtime.expect(mintNum > 0,"Mint must be greater than 0");
		//Runtime.expect(mintNum <= SANDY_SUPPLY,"Maximum number of SANDY has been minted");

    }

	//@Param MintNum - keeps track of how many current mints there are. May need to find a correct way to implement this
    public mintToken(creator:address,to:address,created:timestamp,dna: bytes,name: string,descritpion: string,infoURL: string,imageURL: string,id:number){
        Runtime.expect(Runtime.isWitness(creator),"Must own wallet you are minting from");
        this.mint(creator,to,created,this.insertDNA(dna),name,descritpion,infoURL,imageURL,id);
    
    }
    public transerNFT(from:address,to:address,id:number){
        //Will only have this turned on once.
        Runtime.expect(Runtime.isWitness(from),"Must be owner of NFT to Transfer");
   
            NFT.transfer(from,to,$THIS_SYMBOL,id);

    }

	//will have to make sure that the owner is the only one who can edit the sandy name
    public editSANDY(nftOwner:address,tokenID:number,name:string){
        Runtime.expect(Runtime.isWitness(nftOwner),"Must be owner of NFT");//have to find a way to get current nft owner
		local editRam:body_ram = Struct.body_ram(name);
		//my assumption that write must follow the order of the struct 
        NFT.write(nftOwner,$THIS_SYMBOL,tokenID,editRam);//changeable data


    }
    //need to get readable rom 
    
    //- How do I make return type a struct initiialized to the rom size
    public getRom(symbol:string, id:number):body_rom {
         local nftROM:body_rom = NFT.readROM<body_rom>($THIS_SYMBOL, id);
         
         return nftROM;
    }

    public getRam(symbol:string, id:number): body_ram
    {
        local nftRAM:body_ram = NFT.readRAM<body_ram>($THIS_SYMBOL, id);
        return nftRAM;
    }

    trigger onUpgrade(from:address)
    {
        // check is witness and is current owner
		Runtime.expect(Runtime.isWitness(_owner), "invalid witness");
    }
    //Mint function
    trigger onMint(from: address, to: address, symbol: string, tokenID: number) {
		Runtime.expect(Runtime.isWitness(_owner), "witness failed"); 
		Runtime.expect(symbol == $THIS_SYMBOL, "symbol mismatch");
        //might need to add NFT owns to right here 
    }
    trigger onInfuse(from: address, to: address, symbol: string, tokenID: number){
        Runtime.expect(Runtime.isWitness(from), "witness failed");
    }

    trigger onSeries(from: address){
        Runtime.expect(Runtime.isWitness(from), "witness failed");
    }
    trigger onWrite(from: address,data:number){
        Runtime.expect(Runtime.isWitness(from), "witness failed");
    }
    trigger onSend(from: address, to: address, symbol: string, tokenID: number){
        Runtime.expect(Runtime.isWitness(from), "witness failed");
    }
  
    trigger onBurn(from: address, to: address, symbol: string, tokenID: number) {
		Runtime.expect(Runtime.isWitness(from), "witness failed");
    }

}